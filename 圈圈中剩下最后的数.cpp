/*
题目描述
有个游戏是这样的:首先,让小朋友们围成一个大圈。
然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,
然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,
继续0...m-1报数....这样下去....直到剩下最后一个小朋友,
可以不用表演,请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)


思路：
设 f(n,m):表示 每次在n个数字0，1,...,n-1中删除不停删除第m个数字最后剩下的数字（也就是要求的结果）。
（注意，要求数字标号需要是连续的，所以后面删除一个元素后标号不连续了，需要重新标号）。

在这n个数字中，第一个被删除的数字是 (m-1)%n (取余的原因是m可能比n大)，记作k，则k=(m-1)%n。
删除后的序列为 0,1,...,k-1,k+1,...,n-1。
由于下一次删除是从k+1开始计数的，所以相当于从标号为k+1,k+2,...,n-1,0,1,2,...,k-1的序列中继续删除第m个数字，最终剩下的数字就是结果。

剩下的n-1个数字如果重新按顺序标号得到序列0,1,...,n-2，则每次删除第m个数，最后剩下的数字就是f(n-1,m)。
由于重新标号了，所以并不是f(n,m)=f(n-1,m)! 那么f(n-1,m)对应的数字在修改标号之前是什么数呢？

事实上，原先的不连续的序列A(k+1,k+2,...,n-1,0,1,2,...,k-1)变成了序列B(0,1,...,n-2)，
而我们主要是想知道如何从序列B中的某个数找到序列A中对应的关系，先建立个映射表格：
B序列	        序列A
0	            k+1
1	            k+2
n-k-2	        n-1
n-k-1	        0
n-k	            1
n-2	            k-1
f(n-1,m)	  (f(n-1,m)+k+1)%n

根据表格，可以很直观的看出，在B序列中数字x，对应于A序列中的(x+k+1)%n
（注意：必须取余数，因为B序列中为n-k,而n-k+k+1为n+1,必须取余数才能得到1）。
所以在B序列中标号为f(n-1,m)，对于在A序列中就为(f(n-1,m)+k+1)%n。

还记得k吗，k就是在第一次删除的时候删掉的数(与n有关的变量)，k=(m-1)%n。

将其带入上面的式子，就得到:

(f(n-1,m)+k+1)%n = (f(n-1,m)+(m-1)+1)%n = (f(n-1,m)+m)%n

因此，我们就得到了这个递归公式，而当n=1的时候，也就是序列中只有标号为0的数字，显然最后剩下的数字就是0
所以，f(1) = 0
*/


int LastRemaining_Solution(int n, int m)
{
	if (n < 1 || m < 1) return -1;
	int last = 0;
	for (int i = 2; i <= n; i++) {
		last = (last + m) % i;
	}
	return last;
}